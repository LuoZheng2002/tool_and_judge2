#!/usr/bin/env python3
"""
Test to compare tool formats generated by Python implementation

This test reads the BFCL_v4_multiple.jsonl dataset and generates
tool definitions using the Python implementation, then writes them
to a file for comparison with the Rust implementation.
"""

import json
import re
from pathlib import Path


class FunctionNameMapper:
    """Standalone FunctionNameMapper for testing"""

    def __init__(self):
        self.name_mapping = {}  # sanitized -> original
        self.reverse_mapping = {}  # original -> sanitized

    def get_sanitized_name(self, original_name: str) -> str:
        if original_name in self.reverse_mapping:
            return self.reverse_mapping[original_name]

        existing_sanitized = set(self.name_mapping.keys())
        sanitized_name = self._sanitize_name(original_name, existing_sanitized)

        self.name_mapping[sanitized_name] = original_name
        self.reverse_mapping[original_name] = sanitized_name

        return sanitized_name

    def _sanitize_name(self, name: str, existing_sanitized: set) -> str:
        sanitized = name.replace(".", "_")
        sanitized = re.sub(r'[^a-zA-Z0-9_-]', '_', sanitized)

        if sanitized in existing_sanitized:
            counter = 1
            base_sanitized = sanitized
            while f"{base_sanitized}_{counter}" in existing_sanitized:
                counter += 1
            sanitized = f"{base_sanitized}_{counter}"

        return sanitized


def map_type_hint(ty: str) -> str:
    """Map BFCL type to GPT-5 type"""
    type_mapping = {
        "dict": "object",
        "float": "number",
        "tuple": "array",
    }
    return type_mapping.get(ty, ty)


def sanitize_and_convert_functions_to_tools(functions, name_mapper):
    """Convert BFCL functions to GPT-5 tools format"""
    tools = []

    for func in functions:
        original_name = func.get("name")
        func_description = func.get("description", "")
        func_parameters = func.get("parameters", {})

        # Sanitize function name
        sanitized_name = name_mapper.get_sanitized_name(original_name)

        # Get properties and required fields
        properties = func_parameters.get("properties", {})
        required = func_parameters.get("required", [])

        # Build tool parameters
        tool_properties = {}
        for prop_name, prop_value in properties.items():
            prop_type = prop_value.get("type", "")
            prop_desc = prop_value.get("description", "")

            # Map type
            mapped_type = map_type_hint(prop_type)

            tool_prop = {
                "description": prop_desc
            }

            # Only add type if it's not "any"
            if mapped_type != "any":
                tool_prop["type"] = mapped_type

            # Handle items for arrays
            if "items" in prop_value:
                items = prop_value["items"]
                if isinstance(items, dict) and "type" in items:
                    items_type = map_type_hint(items["type"])
                    tool_prop["items"] = {"type": items_type}

            tool_properties[prop_name] = tool_prop

        # Build tool
        tool = {
            "type": "function",
            "name": sanitized_name,
            "description": func_description,
            "parameters": {
                "type": "object",
                "properties": tool_properties,
                "required": required
            }
        }

        tools.append(tool)

    return tools


def load_bfcl_dataset(dataset_path):
    """Load BFCL dataset from JSONL file"""
    entries = []
    with open(dataset_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                entry = json.loads(line)
                entries.append(entry)
            except json.JSONDecodeError as e:
                print(f"Error parsing line: {e}")
                continue
    return entries


def extract_dataset_info(raw_entry):
    """Extract relevant information from a BFCL dataset entry"""
    entry_id = raw_entry.get("id", "")

    # Extract question content
    question_content = ""
    if "question" in raw_entry and len(raw_entry["question"]) > 0:
        if len(raw_entry["question"][0]) > 0:
            question_content = raw_entry["question"][0][0].get("content", "")

    # Extract function definitions
    functions = raw_entry.get("function", [])

    return entry_id, question_content, functions


def test_python_tool_format_generation():
    """Test tool format generation using Python implementation"""
    dataset_path = "tool/dataset/BFCL_v4_multiple.jsonl"
    output_path = "tool_format_comparison_python.json"

    print(f"Reading dataset from: {dataset_path}")

    # Load dataset
    entries = load_bfcl_dataset(dataset_path)
    print(f"Loaded {len(entries)} entries from dataset")

    results = []

    for i, raw_entry in enumerate(entries):
        entry_id, question_content, functions = extract_dataset_info(raw_entry)

        # Create a fresh name mapper for this entry
        name_mapper = FunctionNameMapper()

        # Generate tools using Python implementation
        tools = sanitize_and_convert_functions_to_tools(functions, name_mapper)

        # Get name mappings
        name_mappings = {
            "original_to_sanitized": name_mapper.reverse_mapping,
            "sanitized_to_original": name_mapper.name_mapping,
        }

        # Create result object
        result = {
            "id": entry_id,
            "question": question_content,
            "tools": tools,
            "name_mappings": name_mappings,
        }

        results.append(result)

    # Write results to output file
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(results, f, indent=2, ensure_ascii=False)

    print(f"Python tool format generation completed. Output written to: {output_path}")
    print(f"Total entries processed: {len(results)}")


if __name__ == "__main__":
    test_python_tool_format_generation()
